---
name: Prepare Release
on:
  workflow_dispatch:
    inputs:
      bump_rule:
        description: 'Select the version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - prerelease
          - patch
          - minor
          - major
      source-branch:
        description: "Create the release from this branch (default: main)."
        required: true
        default: "main"
      date:
        description: "Date of the release (default: today)."
        required: false
        default: ""
      previous-version:
        description: "Previous version to compare against when generating contributors (default: latest git tag)."
        required: false
        default: ""

jobs:
  prepare-release:
    permissions:
      contents: "write"
      pull-requests: "write"
    name: Prepare release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: "actions/checkout@v4"
        with:
          ref: ${{ github.event.inputs.source-branch }}
          fetch-depth: 0  # Fetch all history for git tags

      - name: "Setup environment"
        uses: "networktocode/gh-action-setup-poetry-environment@v6"
        with:
          poetry-version: "2.1.3"
          poetry-install-options: "--only-root"

      - name: Validate Branch and Tags
        run: |
          # 1. Verify branch exists
          if ! git rev-parse --verify origin/${{ github.event.inputs.source_branch }} > /dev/null 2>&1; then
            echo "Error: Branch ${{ github.event.inputs.source_branch }} does not exist."
            exit 1
          fi
          
          # 2. Try to get the previous version tag
          # If it fails (no tags), get the hash of the first commit
          if PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null); then
            echo "PREVIOUS_TAG=$PREV_TAG" >> $GITHUB_ENV
            echo "Found previous tag: $PREV_TAG"
          else
            # Fallback to the first commit in the repository
            FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
            echo "PREVIOUS_TAG=$FIRST_COMMIT" >> $GITHUB_ENV
            echo "No tags found. Falling back to initial commit: $FIRST_COMMIT"
          fi

      - name: Determine New Version
        id: versioning
        run: |
          # Perform the bump based on the user input
          poetry version ${{ github.event.inputs.bump_rule }}
          
          # Capture the New version string for use in other steps
          NEW_VER=$(poetry version --short)
          echo "NEW_VERSION=$NEW_VER" >> $GITHUB_ENV
          echo "RELEASE_BRANCH=release/$NEW_VER" >> $GITHUB_ENV

      - name: Create Release Branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create a new branch for the release
          git checkout -b "${{ env.RELEASE_BRANCH }}"


      - name: "Setup environment"
        uses: "networktocode/gh-action-setup-poetry-environment@v6"
        with:
          poetry-version: "2.1.3"
          poetry-install-options: "--only-root"

      - name: "Regenerate poetry.lock"
        run: "poetry lock --regenerate"

      - name: Generate and Parse Release Notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. Get Towncrier Draft
          TOWNCRIER_NOTES=$(poetry run towncrier build --version "${{ env.NEW_VERSION }}" --draft)

          # 2. Call GitHub API to generate raw notes
          # This is the equivalent of your Python 'generate_notes_url' call
          RAW_GH_NOTES=$(gh api /repos/${{ github.repository }}/releases/generate-notes \
            -f tag_name="v${{ env.NEW_VERSION }}" \
            -f target_commitish="${{ github.event.inputs.source_branch }}" \
            -f previous_tag_name="${{ env.PREVIOUS_TAG }}" --jq '.body')

          # 3. Parse usernames (Regex match)
          # We use grep to find "@user" patterns, sort, and uniq them
          USERNAMES=$(echo "$RAW_GH_NOTES" | grep -oP 'by @\K[a-zA-Z0-9-]+' | sort -u | grep -vE 'dependabot|nautobot-bot' || true)
          
          # 4. Format the Contributors section
          CONTRIBUTORS_SECTION="## Contributors"
          for user in $USERNAMES; do
            CONTRIBUTORS_SECTION="$CONTRIBUTORS_SECTION"$'\n'"* @$user"
          done

          # 5. Extract the "Full Changelog" or "New Contributors" part
          # Using sed to grab everything from '## New Contributors' or '**Full Changelog**' to the end
          GH_FOOTER=$(echo "$RAW_GH_NOTES" | sed -n '/## New Contributors/,$p')
          if [ -z "$GH_FOOTER" ]; then
            GH_FOOTER=$(echo "$RAW_GH_NOTES" | sed -n '/**Full Changelog**/,$p')
          fi

          # 6. Combine everything
          FINAL_NOTES="$TOWNCRIER_NOTES"$'\n\n'"$CONTRIBUTORS_SECTION"$'\n\n'"$GH_FOOTER"
          
          # Save to a temporary file to avoid shell argument length limits
          echo "$FINAL_NOTES" > ../consolidated_notes.md

      - name: Commit Changes and Push
        run: |
          # Add all changes (pyproject.toml, poetry.lock, etc.)
          git add .
          git commit -m "chore: prepare release v${{ env.NEW_VERSION }}"
          git push origin "${{ env.RELEASE_BRANCH }}"

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr create \
            --title "Release v${{ env.NEW_VERSION }}" \
            --body-file "../consolidated_notes.md" \
            --base "${{ github.event.inputs.source_branch }}" \
            --head "${{ env.RELEASE_BRANCH }}"

      - name: Create Draft Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [[ "${{ github.event.inputs.bump_rule }}" == "prerelease" ]]; then
            RELEASE_FLAGS="--prerelease"
          elif [[ "${{ github.event.inputs.source_branch }}" == "main" ]]; then
            RELEASE_FLAGS="--latest"
          else
            RELEASE_FLAGS="--latest=false"
          fi

          gh release create "v${{ env.NEW_VERSION }}" \
            --draft \
            $RELEASE_FLAGS \
            --title "v${{ env.NEW_VERSION }}" \
            --notes-file "../consolidated_notes.md" \
            --target "${{ github.event.inputs.source_branch }}"
# @task(
#     help={
#         "version": "Version of this App to generate the release for or valid poetry bump rule(default: current version).",
#         "source-branch": "Create the release from this branch (default: main).",
#         "date": "Date of the release (default: today).",
#         "previous-version": "Previous version to compare against when generating contributors (default: latest git tag).",
#     }
# )
# def prepare_release(context, version="", ltm="", date="", previous_version=""):
#     """
#     Create a draft GitHub release with the changelog since the last tag.
#     Then generates release notes and creates a PR against main with the release notes.
#     Requires GITHUB_TOKEN environment variable to be set with a token that has repo access.
#     """
#     # Update git first
#     context.run("git fetch", hide=True)
#     # If not on a release branch, exit with an error
#     current_branch = context.run("git rev-parse --abbrev-ref HEAD", hide=True).stdout.strip()
#     if not current_branch.startswith("release"):
#         print(f"Error: Not on a release branch (current: {current_branch})")
#         return
#     # Generate draft release notes first
#     if not version:
#         version = context.run("poetry version --short", hide=True).stdout.strip()
#     context.run(f"poetry version {version}", hide=False)
#     # print(f"Generating draft release notes for version: {version}")
#     towncrier_command = f"poetry run towncrier build --version {version} --draft"
#     if date:
#         towncrier_command += f" --date {date}"
#     notes = context.run(towncrier_command, hide=True).stdout.strip()

#     if not previous_version:
#         # Get the previous release version from git tags
#         previous_version = context.run("git describe --tags --abbrev=0", hide=True)
#         print(f"Previous version: {previous_version.stdout.strip()}")

#     # Generate contributors since last tag using Github API
#     generate_notes_url = (
#         "https://api.github.com/repos/nautobot/nautobot-app-welcome-wizard/releases/generate-notes"
#     )
#     # request_url = (
#     #     f"https://api.github.com/repos/nautobot/nautobot-app-welcome-wizard/compare/{previous_version.stdout.strip()}...{last_commit.stdout.strip()[:7]}"
#     # )
#     headers = {
#         "User-Agent": "Nautobot-Release-Script/1.0",
#         "Accept": "application/vnd.github+json",
#         "Authorization": f"Bearer {os.getenv('GITHUB_TOKEN')}",
#         "X-GitHub-Api-Version": "2022-11-28",
#     }
#     try:
#         commitish = "develop"
#         if ltm:
#             commitish = ltm
#         req = Request(generate_notes_url, headers=headers, method="POST", data=json.dumps({"tag_name": version, "previous_tag_name": previous_version.stdout.strip(), "target_commitish": commitish}).encode())
#         with urlopen(req) as response:
#             if response.status != 200:
#                 print(f"Error fetching release notes: {response.status} {response.reason}")
#                 return
#             notes_response = response.read().decode("utf-8")
#             # print(notes)
#             notes_json = json.loads(notes_response)
#             github_notes = notes_json.get("body", "")
#             # Parse out the @usernames from the release notes sort and deduplicate
#             usernames = set(re.findall(r"by @([a-zA-Z0-9-]+)", github_notes))
#             # Keep the ## New Contributors section and everything after
#             if "## New Contributors" in github_notes:
#                 github_notes = github_notes[github_notes.index("## New Contributors"):].strip()
#             else:
#                 github_notes = github_notes[github_notes.index("**Full Changelog**"):].strip()
#             ##github_notes += "\n\n## Contributors\n"
#             notes += "\n\n## Contributors\n"
#             for username in sorted(usernames):
#                 if username not in ["dependabot[bot]", "nautobot-bot"]:
#                     notes += f"* @{username}\n"
#             notes += "\n" + github_notes
#     except Exception as exc:
#         print(f"Error fetching contributors from GitHub API: {exc}")

#     # Create the release in GitHub
#     release_url = "https://api.github.com/repos/nautobot/nautobot-app-welcome-wizard/releases"
#     try:
#         req = Request(release_url, headers=headers, method="POST", data=json.dumps({
#             "tag_name": version,
#             "target_commitish": ltm if ltm else "main",
#             "name": f"{version}",
#             "body": notes,
#             "draft": True,
#             "prerelease": bool(re.match(r".*(a|b|rc)\d*$", version)),
#             "latest": not bool(ltm or re.match(r".*(a|b|rc)\d*$", version)),
#         }).encode())
#         with urlopen(req) as response:
#             if response.status != 201:
#                 print(f"Error creating release: {response.status} {response.reason}")
#                 return
#             release_response = response.read().decode("utf-8")
#             release_json = json.loads(release_response)
#             html_url = release_json.get("html_url", "")
#             print(f"Draft release created: {html_url}")
#     except Exception as exc:
#         print(f"Error creating release in GitHub: {exc}")
#         return

#     generate_release_notes(context, version=version, date=date, keep=False)